%-------------------------------------------------------------------------% 程序Fun_ReadECGData 用于读取ECG信号数据，将原始的二值数据转换为十进制数% 输入参数及其示例： PATH= 'C:\Users\YaliKiWi\Desktop\NUS\teamwork\program'; % 指定数据的储存路径 HEADERFILE= '0001.hea';      % .hea 格式，头文件，可用记事本打开 DATAFILE='0001.dat';         % .dat 格式，ECG 数据 SAMPLES2READ=2048;          % 指定需要读入的样本数%                             % 若.dat文件中存储有两个通道的信号:%                             % 则读入 2*SAMPLES2READ 个数据 % 输出参数：M —— 一个SAMPLES2READ行2列的数据矩阵，每列数据代表一个通道的信号值%-------------------------------------------------------------------------                            function M = Fun_ReadECGData(PATH,HEADERFILE,DATAFILE,SAMPLES2READ)%------ LOAD HEADER DATA --------------------------------------------------%------ 读入头文件数据 -----------------------------------------------------%% 示例：用记事本打开的117.hea 文件的数据%%      117 2 360 650000%      117.dat 212 200 11 1024 839 31170 0 MLII%      117.dat 212 200 11 1024 930 28083 0 V2%      # 69 M 950 654 x2%      # None%%-------------------------------------------------------------------------%-------------------------------------------------------------------------% 【注】函数 fprintf 的功能将格式化的数据写入到指定文件中。% 表达式：count = fprintf(fid,format,A,...)% 在字符串'format'的控制下，将矩阵A的实数数据进行格式化，并写入到文件对象fid中。该函数返回所写入数据的字节数 count。% fid 是通过函数 fopen 获得的整型文件标识符。fid=1，表示标准输出（即输出到屏幕显示）；fid=2，表示标准偏差。%-------------------------------------------------------------------------fprintf(1,'//n$> WORKING ON %s .../n', HEADERFILE);   % 在Matlab命令行窗口提示当前工作状态signalh= fullfile(PATH, HEADERFILE);                           % 通过函数 fullfile 获得头文件的完整路径fid1=fopen(signalh,'r');                            % 打开头文件，其标识符为 fid1 ，属性为'r'--“只读”z= fgetl(fid1);                                        % 读取头文件的第一行数据，字符串格式A= sscanf(z, '%*s %d %d %d',[1,3]);      % 按照格式 '%*s %d %d %d' 转换数据并存入矩阵 A 中nosig= A(1);                                         % 信号通道数目sfreq=A(2);                                           % 数据采样频率clear A;                                                % 清空矩阵 A ，准备获取下一行数据for k=1:nosig                                         % 读取每个通道信号的数据信息    z= fgetl(fid1);    A= sscanf(z, '%*s %d %d %d %d %d',[1,5]);    dformat(k)= A(1);                                % 信号格式; 这里只允许为 212 格式    gain(k)= A(2);                                     % 每 mV 包含的整数个数    bitres(k)= A(3);                                   % 采样精度（位分辨率）    zerovalue(k)= A(4);                              % ECG 信号零点相应的整数值    firstvalue(k)= A(5);                               % 信号的第一个整数值 (用于偏差测试)end;fclose(fid1);clear A;%------ LOAD BINARY DATA --------------------------------------------------%------ 读取 ECG 信号二值数据 ----------------------------------------------%% 说明：.dat 文件的数据格式%%      用 uint8 格式读入 N 个样本，存入矩阵 A 中，则 A 有 N 行、3列，每列一个字节，%      即每行用三个字节表示两个数m1、m2，每个数 12 bits，故又称为 212 格式%      m1的低8位存放在 A（:,1），m2的低8位存放在A（:,3），%      m1的高4位存放在A（:,2）的低4位，m2的高4位存放在A（:,2）的高4位%      % 根据上述数据格式，可以用一系列移位、位与操作，提取出十进制格式的双通道信号数据%%-------------------------------------------------------------------------if dformat~= [212,212], error('this script does not apply binary formats different to 212.'); endsignald= fullfile(PATH, DATAFILE);                    % 读入 212 格式的 ECG 信号数据fid2=fopen(signald,'r');A= fread(fid2, [3, SAMPLES2READ], 'uint8')';      % 矩阵A共有SAMPLES2READ行、3列，每列数据都是以uint8格式读入，注意这时数据通过uint8的读入方式已经成为十进制数了fclose(fid2);M2H= bitshift(A(:,2), -4);                          % 字节向右移四位，即取字节的高四位，属于信号2的高4位M1H= bitand(A(:,2), 15);                          % 取字节的低四位，属于信号1的高4位PRL=bitshift(bitand(A(:,2),8),9);                % sign-bit   取出字节低四位中最高位，向左移九位PRR=bitshift(bitand(A(:,2),128),5);            % sign-bit   取出字节高四位中最高位，向左移五位M( : , 1)= bitshift(M1H,8)+ A(:,1)-PRL;       % 将M1H、M2H分别左移8位，即乘以2^8，再分别加上A(:,1)，A(:,2)，M( : , 2)= bitshift(M2H,8)+ A(:,3)-PRR;      % 由于左移时把符号位也移动了，要减去符号位的值M=M';            % 为了方便后期的数据处理，将输出矩阵 M 转置为2行SAMPLES2READ列end